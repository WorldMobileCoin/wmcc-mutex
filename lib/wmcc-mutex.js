module.exports=function(s){var t={};function e(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return s[r].call(o.exports,o,o.exports,e),o.l=!0,o.exports}return e.m=s,e.c=t,e.d=function(s,t,r){e.o(s,t)||Object.defineProperty(s,t,{configurable:!1,enumerable:!0,get:r})},e.n=function(s){var t=s&&s.__esModule?function(){return s.default}:function(){return s};return e.d(t,"a",t),t},e.o=function(s,t){return Object.prototype.hasOwnProperty.call(s,t)},e.p="",e(e.s=1)}([function(s,t){s.exports=require("assert")},function(s,t,e){"use strict";t.Lock=e(2),t.MapLock=e(3)},function(s,t,e){"use strict";const r=e(0);class o{constructor(s=!1){this.named=!0===s,this.jobs=[],this.busy=!1,this.destroyed=!1,this.map=new Map,this.current=null,this.unlocker=this.unlock.bind(this)}static create(s){const t=new o(s);return function(s,e){return t.lock(s,e)}}has(s){return r(this.named,"Must use named jobs."),this.current===s||this.pending(s)}pending(s){r(this.named,"Must use named jobs.");const t=this.map.get(s);return null!=t&&t>0}lock(s,t){let e,o;if(this.named?(e=s||null,o=t||!1):(e=null,o=s||!1),this.destroyed)return Promise.reject(new Error("Lock is destroyed."));if(o)return r(this.busy),Promise.resolve(i);if(this.busy){if(e){const s=this.map.get(e)||0;this.map.set(e,s+1)}return new Promise((s,t)=>{this.jobs.push(new n(s,t,e))})}return this.busy=!0,this.current=e,Promise.resolve(this.unlocker)}unlock(){if(r(this.destroyed||this.busy),this.busy=!1,this.current=null,0===this.jobs.length)return;r(!this.destroyed);const s=this.jobs.shift();if(s.name){let t=this.map.get(s.name);r(t>0),0==--t?this.map.delete(s.name):this.map.set(s.name,t)}this.busy=!0,this.current=s.name,s.resolve(this.unlocker)}destroy(){r(!this.destroyed,"Lock is already destroyed."),this.destroyed=!0;const s=this.jobs;for(const t of(this.busy=!1,this.jobs=[],this.map.clear(),this.current=null,s))t.reject(new Error("Lock was destroyed."))}}class n{constructor(s,t,e){this.resolve=s,this.reject=t,this.name=e||null}}function i(){}s.exports=o},function(s,t,e){"use strict";const r=e(0);class o{constructor(){this.jobs=new Map,this.busy=new Set,this.destroyed=!1}static create(){const s=new o;return function(t,e){return s.lock(t,e)}}has(s){return this.busy.has(s)}pending(s){return this.jobs.has(s)}lock(s,t=!1){return this.destroyed?Promise.reject(new Error("Lock is destroyed.")):null==s?Promise.resolve(i):t?(r(this.busy.has(s)),Promise.resolve(i)):this.busy.has(s)?new Promise((t,e)=>{this.jobs.has(s)||this.jobs.set(s,[]),this.jobs.get(s).push(new n(t,e))}):(this.busy.add(s),Promise.resolve(this.unlock(s)))}unlock(s){const t=this;return function e(){const o=t.jobs.get(s);if(r(t.destroyed||t.busy.has(s)),t.busy.delete(s),!o)return;r(!t.destroyed);const n=o.shift();r(n),0===o.length&&t.jobs.delete(s),t.busy.add(s),n.resolve(e)}}destroy(){r(!this.destroyed,"Lock is already destroyed.");const s=this.jobs;for(const t of(this.destroyed=!0,this.jobs=new Map,this.busy=new Map,s.values()))for(const s of t)s.reject(new Error("Lock was destroyed."))}}class n{constructor(s,t){this.resolve=s,this.reject=t}}function i(){}s.exports=o}]);